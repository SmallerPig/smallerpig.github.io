---
title: 小猪学设计模式之—装饰者模式
id: 323
categories:
  - 设计模式
date: 2013-10-09 17:15:30
tags:
  - 设计模式
---

**装饰者模式**

动态地给一个对象添加一些额外的职责，就增加功能来说，Decorator模式比生成子类更为灵活。

**装饰者模式的工作原理：**

可以创建始于Decorator对象（负责新的功能的对象）终于原对象的一个对象“链”。
```
A=>装饰=>B=>装饰=>C=>装饰=>D=>装饰=>实体

 
```
装饰者模式隐含的是通过一条条装饰链去实现具体对象，每一条装饰链都始于一个Componet对象，每个装饰者对象后面紧跟着另一个装饰者对象，而对象链终于ConcreteComponet对象。

**装饰者模式UML图**

ConcreteComponent：让Decorator对象为自己添加功能。有时候使用ConcreteComponent的派生类提供核心功能，在这种情况就是用ConcreteComponent替代了Component的功能，而且装饰者是继承于ConcreteComponent的子类。

Component：定义ConcreteComponent和Decorator类要实现的方法，简单来说如果一个类继承于该类就具有装饰或被装饰能力。

Decorator：具有特定装饰功能的类，用来装饰ConcreteComponent类。

&nbsp;

&nbsp;

**装饰者模式的应用场景：**

1、  想透明并且动态地给对象增加新的职责的时候。

2、  给对象增加的职责，在未来存在增加或减少可能。

3、  用继承扩展功能不太现实的情况下，应该考虑用组合的方式。

**装饰者模式的优点：**

1、  通过组合而非继承的方式，实现了动态扩展对象的功能的能力。

2、  有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。

3、  充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。

4、  装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。

5、  遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。

**装饰者模式的缺点：**

1、  装饰链不能过长，否则会影响效率。

2、  因为所有对象都是继承于Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合(Decoator HAS A Component)建立的关系只会影响被装饰对象的外部特征。

3、只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。