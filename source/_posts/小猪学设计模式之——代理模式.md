---
title: 小猪学设计模式之——代理模式
tags:
  - 代理模式
  - 设计模式
id: 1111
categories:
  - 设计模式
date: 2016-09-29 15:40:28
---

> 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

## 参与的角色

　　●　　**抽象对象角色**：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
　　●　　**目标对象角色**：定义了代理对象所代表的目标对象。
　　●　　**代理对象角色**：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。

## 示例代码

抽象对象角色
``` java
    public abstract class AbstractObject {
        public abstract void operation();
    }


```

目标对象角色

``` java

 public class RealObject extends AbstractObject {
    @Override
    public void operation() {
        //具体做一些事情。
        System.out.println("一些操作");
    }
}


```

代理对象角色

``` java

 public class ProxyObject extends AbstractObject{

    //内部含有目标对象的引用
    RealObject realObject = new RealObject();

    @Override
    public void operation() {
        //调用目标对象之前可以做相关操作
        System.out.println("do something before");        
        realObject.operation();        
        //调用目标对象之后可以做相关操作
        System.out.println("do something after");
    }
}


```

客户端代码：

```  java

 public class Client {

    public static void main(String[] args) {
        //这里的真实对象就被代理对象给“代理”了，客户端并不知道真实对象的存在
        AbstractObject obj = new ProxyObject();
        obj.operation();
    }
}
```

由例子可以看出被代理的对象在客户端代码中并没有实际出现，客户端也就不关心真正的执行是什么样子了，而且代理类可以在被代理类执行的前后执行一些额外的功能代码。被代理的对象一般可以概括为：
1\. 远程对象
2\. 创建开销大的对象
3\. 需要安全控制的对象

在《设计模式》一书中作者列举了这样一个例子：

> 对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。我们考虑一个可以在文档中嵌入图像对象的文档编辑器。有些图像对象（如大型的光栅图像）的创建开销很大。但打开文档必须很迅速，因此我们在打开文档时应避免一次性的创建所有开销很大的对象。因为并非所有这些开销很大的对象在文档中都同时可见。所以并没有必要同时创建这些对象。
>   这一限制条件意为着，对于每一个开销很大的对象，应该根据需要进行创建，当一个图像对象变成可见时会有这样的需要。但是在文档中我们用什么来代理这个图像呢？我们又如何才能隐藏根据需要创建图像这个事实，从而不会使得编辑器的实现复杂化呢？例如，这种优化不应该影响绘制和格式化的代码。
>   问题的解决方法是使用另外一个对象，即图像Proxy，替代那个真实的图像，Proxy可以代替一个图像对象，并且在需要时负责实例化这个图像对象。只要当文档编辑器激活图像代理的Draw操作以显示这个图像的时候，图像Proxy才创建真正的图像。Proxy直接将随后的请求转发给这个图像对象。

## 总结

又是一个对多态概念的具体实现的模式。
很多时候在面试时都会问被面的人，什么叫面向对象的多态，可惜的是很多同学都答不上来啊。