---
title: 'C#抽象类、抽象方法、抽象属性'
id: 311
categories:
  - 'C#'
date: 2013-09-13 16:41:10
tags:
---

**定义**

在C#中使用关键字 abstract 来定义抽象类和抽象方法。

不能初始化的类被叫做抽象类，它们只提供部分实现，但是另一个类可以继承它并且能创建它们
的实例。
&quot;一个包含一个或多个纯虚函数的类叫抽象类，抽象类不能被实例化，进一步
一个抽象类只能通过接口和作为其它类的基类使用.&quot;- C++ Programming Language by Stroustrup Chapter13.2

抽象类能够被用于类，方法，属性，索引器和事件，使用abstract 在一个类声明中表示该类倾向要作为其它类的基类
成员被标示成abstract，或被包含进一个抽象类，必须被其派生类实现。
```


abstract class ShapesClass

    {

        abstract public int Area\(\);

    }

    class Square : ShapesClass

    {

        int x, y;

        // Not providing an Area method results

        // in a compile-time error.

        public override int Area\(\)

        {

            return x * y;

        }

    }

 ```

**备注**
**抽象类具有以下特性：**
1、抽象类不能实例化。
2、抽象类可以包含抽象方法和抽象访问器。
3、不能用 sealed（C# 参考）修饰符修改抽象类，这意味着抽象类不能被继承。
4、从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。
5、抽象类可以是抽象方法和实例方法。
在方法或属性声明中使用 abstract 修饰符以指示方法或属性不包含实现。
**抽象方法具有以下特性：**
1、抽象方法是隐式的虚方法。
2、只允许在抽象类中使用抽象方法声明。
3、因为抽象方法声明不提供实际的实现，所以没有方法体；方法声明只是以一个分号结束，并且在签名后没有大括号 ({ })。例如：

```


public abstract void MyMethod\(\);

 ```

4、实现由一个重写方法提供，此重写方法是非抽象类的成员。
5、在抽象方法声明中使用 static 或 virtual 修饰符是错误的。

**除了在声明和调用语法上不同外，抽象属性的行为与抽象方法一样。**
1、在静态属性上使用 abstract 修饰符是错误的。
2、在派生类中，通过包括使用 override 修饰符的属性声明，可以重写抽象的继承属性。
抽象类必须为所有接口成员提供实现。
实现接口的抽象类可以将接口方法映射到抽象方法上。例如：

```


interface I
{
    void M\(\);
}
abstract class C: I
{
    public abstract void M\(\);
}

 ```

**示例**
在本例中，DerivedClass 类是从抽象类 BaseClass 派生的。抽象类包含一个抽象方法 AbstractMethod 和两个抽象属性 X 和 Y。

```


// abstract_keyword.cs
// Abstract Classes
using System;
abstract class BaseClass   // Abstract class
{
    protected int _x = 100;
    protected int _y = 150;
    public abstract void AbstractMethod\(\);   // Abstract method
    public abstract int X    { get; }
    public abstract int Y    { get; }
}
class DerivedClass : BaseClass
{
    public override void AbstractMethod\(\)
    {
        _x++;
        _y++;
    }
    public override int X   // overriding property
    {
        get
        {
            return _x + 10;
        }
    }
    public override int Y   // overriding property
    {
        get
        {
            return _y + 10;
        }
    }
    static void Main\(\)
    {
        DerivedClass o = new DerivedClass\(\);
        o.AbstractMethod\(\);
        Console.WriteLine("x = {0}, y = {1}", o.X, o.Y);
    }
}

 ```

输出
x = 111, y = 161
注释
在上面的示例中，如果试图通过使用下面的语句将抽象类实例化：

```


BaseClass bc = new BaseClass\(\); // Error

 ```

将出现错误，指出编译器无法创建抽象类“BaseClass”的实例。

在定义类的前面加上关键字abstract，那么这个类就是抽象类了，抽象类本身无法产生实例对象，而且抽象类包含了一个以上的抽象方法，这些方法只是提供函数名称，并没有定义如何具体实现，由继承的派生类实现，派生类同时必须实现所有抽象类的方法，否则其本身将成为另外一个抽象类。需要我们注意的一点是，当派生类重写抽象类的方法时，要使用override关键字来重写抽象类所定义的方法。