---
title: 自定义生成二维码
id: 381
categories:
  - Android
  - WEB开发
date: 2014-01-04 15:43:36
tags:
---

# 
	前言

	二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。

	关于QR Code Specification，可参看这个PDF：http://raidenii.net/files/datasheets/misc/qr_code.pdf&nbsp;

# 
	基础知识

	首先，我们先说一下二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。

	下面我们看看一个二维码的样例：

	[![](http://coolshell.cn//wp-content/uploads/2013/10/QR-Code-Overview.jpeg)](http://coolshell.cn//wp-content/uploads/2013/10/QR-Code-Overview.jpeg)

```
## 

定位图案

	**Position Detection Pattern** 是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。

	**Timing Patterns** 也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。

	**Alignment Patterns** 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。

```
## 

功能性数据

	**Format Information** 存在于所有的尺寸中，用于存放一些格式化数据的。

	**Version Information** 在 &gt;= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。

```
## 

数据码和纠错码

	除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。

# 
	数据编码

	我们先来说说数据编码。QR码支持如下的编码：

	**Numeric mode**&nbsp;数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）

	**Alphanumeric mode**&nbsp;字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + &ndash; . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）

	![](http://images.cnitblog.com/news/66372/201310/29105437-d29c553d2188454e856435c70f816fee.png)

	**Byte mode**, 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。

	**Kanji mode**&nbsp;这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把结果前两个16进制位拿出来乘以0XC0，然后再加上后两个16进制位，最后转成13bit的编码。如下图示例：

	![](http://images.cnitblog.com/news/66372/201310/29105437-8f99f7c257b64169b83a54925a1f1954.png)

	**Extended Channel Interpretation (ECI) mode**&nbsp;主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。

	**Structured Append mode**&nbsp;用于混合编码，也就是说，这个二维码中包含了多种编码格式。

	**FNC1 mode**&nbsp;这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。

	简单起见，后面三种不会在本文 中讨论。

	下面两张表中，

	Table 2 是各个编码格式的&ldquo;编号&rdquo;，这个东西要写在Format Information中。注：中文是1101

	Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）

	![](http://coolshell.cn//wp-content/uploads/2013/10/Mode-Indicator.png)​

	下面我们看几个示例，

```
## 

示例一：数字编码

	在Version 1的尺寸下，纠错级别为H的情况下，编码： 01234567

	1\. 把上述数字分成三组: 012 345 67

	2\. 把他们转成二进制: &nbsp;012 转成 0000001100； &nbsp;345 转成 0101011001； &nbsp;67 转成 1000011。

	3\. 把这三个二进制串起来: 0000001100 0101011001 1000011

	4\. 把数字的个数转成二进制 (version 1-H是10 bits ):&nbsp;8个数字的二进制是 0000001000

	5\. 把数字编码的标志0001和第4步的编码加到前面: &nbsp;0001 0000001000 0000001100 0101011001 1000011

```
## 

示例二：字符编码

	在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-42

	1\. 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)

	2\. 两两分组: (10,12) (41,4) (2)

	3.把每一组转成11bits的二进制:

	(10,12) 10*45+12 等于 462 转成 00111001110

	(41,4) 41*45+4 等于 1849 转成 11100111001

	(2) 等于 2 转成 000010

	4\. 把这些二进制连接起来：00111001110 11100111001 000010

	5\. 把字符的个数转成二进制 (Version 1-H为9 bits ):&nbsp;5个字符，5转成 000000101

	6\. 在头上加上编码标识 0010 和第5步的个数编码: &nbsp;0010 000000101 00111001110 11100111001 000010

# 
	结束符和补齐符

	假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，

<table style="border: 2px solid rgb(204, 204, 204); border-collapse: collapse; margin: 5px 0px 10px; color: rgb(85, 85, 85); font-family: Arial, Verdana, 'BitStream vera Sans', Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 23px;">
	<tbody>
		<tr>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				编码
			</th>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				字符数
			</th>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				HELLO WORLD的编码
			</th>
		</tr>
		<tr>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				0010
			</td>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				000001011
			</td>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				01100001011 01111000110 10001011100 10110111000 10011010100 001101
			</td>
		</tr>
	</tbody>
</table>

	我们还要加上结束符：

<table style="border: 2px solid rgb(204, 204, 204); border-collapse: collapse; margin: 5px 0px 10px; color: rgb(85, 85, 85); font-family: Arial, Verdana, 'BitStream vera Sans', Tahoma, Helvetica, sans-serif; font-size: 16px; line-height: 23px;">
	<tbody>
		<tr>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				编码
			</th>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				字符数
			</th>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				HELLO WORLD的编码
			</th>
			<th style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top; background-color: rgb(237, 239, 240);">
				结束
			</th>
		</tr>
		<tr>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				0010
			</td>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				000001011
			</td>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				01100001011 01111000110 10001011100 10110111000 10011010100 001101
			</td>
			<td style="border: 1px solid rgb(204, 204, 204); padding: 3px 10px; vertical-align: top;">
				0000
			</td>
		</tr>
	</tbody>
</table>

```
## 

按8bits重排

	如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：

	00100000 &nbsp; 01011011 &nbsp; 00001011 &nbsp; 01111000 &nbsp; 11010001 &nbsp; 01110010 &nbsp; 11011100 &nbsp; 01001101 &nbsp; 01000011 &nbsp; 010000<span style="color:#FF0000;">00</span>

```
## 

补齐码（Padding Bytes）

	最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看QR Code Spec的第28页到32页的Table-7一表。

	假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要补24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：

	00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000&nbsp;<span style="color:#FF0000;">11101100 00010001 11101100</span>

	上面的编码就是数据码了，叫Data Codewords，每一个8bits叫一个codeword，我们还要对这些数据码加上纠错信息。

# 
	画二维码图

#```
## 

1、Position Detection Pattern

	首先，先把Position Detection图案画在三个角上。（无论Version如何，这个图案的尺寸就是这么大）

	![](http://images.cnitblog.com/news/66372/201310/29105438-7b5a8ec528bc4784aed702150ba944bf.png)

#```
## 

2、Alignment Pattern

	然后，再把 Alignment 图案画上

	![](http://coolshell.cn//wp-content/uploads/2013/10/alignment-pattern.png)

	关于Alignment的位置，可以查看[QR Code Spec](http://raidenii.net/files/datasheets/misc/qr_code.pdf)的第81页的Table-E.1的定义表（下表是不完全表格）

	![](http://coolshell.cn//wp-content/uploads/2013/10/Alignment-Position.png)

	下图是根据上述表格中的 Version8 的一个例子（6，24，42）

	![](http://images.cnitblog.com/news/66372/201310/29105439-1719e93bdf5749f68dcb6d5025c443f6.png)

#```
## 

3、Timing Pattern

	接下来是 Timing Pattern 的线（这个不用多说了）

	&nbsp;

	![](http://images.cnitblog.com/news/66372/201310/29105440-c15552dfb2d743b88aeb0a36cd74ca62.png)

#```
## 

4、Format Information

	再接下来是 Formation Information，下图中的蓝色部分。

	![](http://images.cnitblog.com/news/66372/201310/29105440-377d20ad105649ec9895eb72b154dd4f.png)

	Format Information 是一个 15 个 bits 的信息，每一个 bit 的位置如下图所示：（注意图中的 Dark Module，那是永远出现的）

	![](http://images.cnitblog.com/news/66372/201310/29105440-7561c34ba56c47b5a6278f07c370cd99.png)

	这 15 个 bits 中包括：

*   5 个数据 bits：其中，2 个 bits 用于表示使用什么样的 Error Correction Level， 3 个 bits 表示使用什么样的 Mask
*   10 个纠错 bits。主要通过 BCH Code 来计算

	然后 15 个 bits 还要与 101010000010010 做 XOR 操作。这样就保证不会因为我们选用了 00 的纠错级别，以及 000 的 Mask，从重造成全部为白色，这会增加我们的扫描器的图像识别的困难。

	下面是一个示例：

	![](http://images.cnitblog.com/news/66372/201310/29105441-aa7ffa24e06e41d68004fb951c2f7137.png)​

	关于 Error Correction Level 如下表所示：

	![](http://images.cnitblog.com/news/66372/201310/29105439-e33b056eb217421fb37bb3628c0cd4b9.png)

	关于 Mask 图案如后面的 Table 23 所示。

#```
## 

5、Version Information

	再接下来是 Version Information（版本 7 以后需要这个编码），下图中的蓝色部分。

	![](http://images.cnitblog.com/news/66372/201310/29105440-ebb2a858b1454f8f9b326ff7923e7b14.png)

	Version Information 一共是 18 个 bits，其中包括 6 个 bits 的版本号以及 12 个 bits 的纠错码，下面是一个示例：

	![](http://images.cnitblog.com/news/66372/201310/29105440-d7f867d0c7574565a34054adfec67fc2.png)

	而其填充位置如下：

	![](http://images.cnitblog.com/news/66372/201310/29105440-8dd3bad838e54ad3ba2acc809594b5ba.png)

#```
## 

6、数据和数据纠错码

	然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个 bits，1 是黑色，0 是白色。如果遇到了上面的非数据区，则绕开或跳过。

	![](http://images.cnitblog.com/news/66372/201310/29105440-b64b7060d04d407b8eaf179358c8b1f6.png)

#```
## 

7、掩码图案

	这样下来，我们的图就填好了，但是，也许那些点并不均衡，所以，我们还要做 Masking 操作（靠，还嫌不复杂）QR 的 Spec 中说了，QR 有 8 个 Mask 你可以使用，如下所示：其中，各个 mask 的公式在各个图下面。所谓 mask，说白了，就是和上面生成的图做 XOR 操作。Mask 只会和数据区进行 XOR，不会影响功能区。

	![](http://images.cnitblog.com/news/66372/201310/29105441-4dfe5e39dfd6463ea59371c9a7ad21d4.png)

	其 Mask 的标识码如下所示：（其中的i,j分别对应于上图的x，y）

	![](http://images.cnitblog.com/news/66372/201310/29105440-4e7ad668f51047a8bd74fe1f1a5f5f34.png)

	下面是 Mask 后的一些样子，我们可以看到被某些 Mask XOR 了的数据变得比较零散了。

	![](http://images.cnitblog.com/news/66372/201310/29105441-87fe053c9d174ffd85080fdb61359f82.png)

	Mask 过后的二维码就成最终的图了。

	好了，大家可以去尝试去写一下 QR 的编码程序，当然，你可以用网上找个 Reed Soloman 的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。

	&nbsp;

	&nbsp;

	原文地址：[http://coolshell.cn/articles/10590.html](http://coolshell.cn/articles/10590.html)